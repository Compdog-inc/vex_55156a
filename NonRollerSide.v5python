{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nflywheel_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nflywheel_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nflywheel = MotorGroup(flywheel_motor_a, flywheel_motor_b)\nintake = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\nroller = Motor(Ports.PORT4, GearSetting.RATIO_18_1, False)\nindexer = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nleft_drive_smart = Motor(Ports.PORT8, GearSetting.RATIO_36_1, False)\nright_drive_smart = Motor(Ports.PORT7, GearSetting.RATIO_36_1, True)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)\ncontroller_1 = Controller(PRIMARY)\nled_a = Led(brain.three_wire_port.a)\nexpansion = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_left_shoulder_control_motors_stopped = True\ncontroller_1_up_down_buttons_control_motors_stopped = True\ndrivetrain_l_needs_to_be_stopped_controller_1 = False\ndrivetrain_r_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_l_needs_to_be_stopped_controller_1, drivetrain_r_needs_to_be_stopped_controller_1, controller_1_left_shoulder_control_motors_stopped, controller_1_up_down_buttons_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3 + axis1\n            # right = axis3 - axis1\n            drivetrain_left_side_speed = controller_1.axis3.position() + controller_1.axis1.position()\n            drivetrain_right_side_speed = controller_1.axis3.position() - controller_1.axis1.position()\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller_1:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller_1 = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller_1:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n            # check the buttonL1/buttonL2 status\n            # to control flywheel\n            if controller_1.buttonL1.pressing():\n                flywheel.spin(FORWARD)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif controller_1.buttonL2.pressing():\n                flywheel.spin(REVERSE)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif not controller_1_left_shoulder_control_motors_stopped:\n                flywheel.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_left_shoulder_control_motors_stopped = True\n            # check the buttonUp/buttonDown status\n            # to control roller\n            if controller_1.buttonUp.pressing():\n                roller.spin(FORWARD)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif controller_1.buttonDown.pressing():\n                roller.spin(REVERSE)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif not controller_1_up_down_buttons_control_motors_stopped:\n                roller.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_up_down_buttons_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:\n#\tAuthor:\n#\tCreated:\n#\tConfiguration:\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nimport sys\nimport random\nimport math\n\nplaying = False\nbirdX = 0\nbirdY = 0\nbirdVelY = 0\nbirdScrollSpeed = 3\n\nobstacles = []\nonstacleCounter = 0\nobstacleRate = 50\n\nscore = 0\nprevJump = False\n\nexpansionCounter = 0\nprevXBtn = False\nrunning = True\n\nphysxDebug = []\nphysxCounter = 0\n\nprevTime = brain.timer.time(MSEC)\n\nCALCULATIONS_PER_FRAME = 1\n\n# Begin project code\n\ndef pre_autonomous():\n    # actions to do when the program starts\n    brain.screen.clear_screen()\n    brain.screen.print(\"pre auton code\")\n    expansion.set_stopping(HOLD)\n    wait(1, SECONDS)\n\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"autonomous code\")\n    # presets\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    flywheel.set_velocity(100, PERCENT)\n    roller.set_velocity(50, PERCENT)\n    # place automonous code here\n    drivetrain.turn_for(LEFT, 10, DEGREES)\n    flywheel.spin(FORWARD)\n    wait(2, SECONDS)\n    indexer.set_position(0, DEGREES)\n    indexer.spin_for(REVERSE, 1, TURNS)\n    wait(2, SECONDS)\n    indexer.spin_for(REVERSE, 1, TURNS)\n    indexer.spin_to_position(-720, DEGREES)\n    flywheel.stop()\n\ndef user_control():\n    brain.screen.clear_screen()\n    intake.set_velocity(100, PERCENT)\n    flywheel.set_velocity(80, PERCENT)\n    indexer.set_velocity(20, PERCENT)\n    \n\n    def index():\n       indexer.set_position(0, DEGREES)\n       indexer.spin_for(REVERSE, 1, TURNS)\n       indexer.spin_to_position(-360, DEGREES)\n\n    def intakeCurve(t, mul):\n        norm = t / 2 # intake takes 2 seconds\n        if norm > 1:\n            norm = 1\n        vel = 70 + (1-norm) * (100-70)\n        intake.set_velocity(vel * mul, PERCENT)\n        return vel\n\n    def drawGraph(a,b,x,y,cx,cy,col1,col2):\n       brain.screen.set_fill_color(Color.BLACK);\n       brain.screen.set_pen_width(0);\n       brain.screen.draw_rectangle(x,y,290,112);\n       brain.screen.set_pen_width(1);\n       brain.screen.set_fill_color(Color.TRANSPARENT);\n       brain.screen.set_pen_color(Color.WHITE)\n       brain.screen.draw_rectangle(x,y,100,100)\n       brain.screen.draw_line(x,y+100,x+100,y)\n       brain.screen.set_fill_color(col1)\n       brain.screen.draw_rectangle(x+a*100,y+(1-a)*100,10,10)\n       brain.screen.set_fill_color(col2)\n       brain.screen.draw_rectangle(x+b*100,y+(1-b)*100,10,10)\n       brain.screen.set_fill_color(Color.TRANSPARENT)\n       brain.screen.set_pen_color(col1)\n       brain.screen.set_cursor(cy,cx)\n       brain.screen.print(str(a*100)+\" [percent]\")\n       brain.screen.set_pen_color(col2)\n       brain.screen.set_cursor(cy+1,cx)\n       brain.screen.print(str(b*100)+\" [percent]\")\n       brain.screen.set_pen_color(Color.WHITE)\n\n    def calculatePosition(tm, accelY):\n        global birdX, birdY, birdScrollSpeed, birdVelY\n        return [\n            birdX + birdScrollSpeed * 50 * tm,\n            birdY + birdVelY * tm + 0.5 * accelY * tm * tm\n        ]\n\n    def predictCollision(targetY, accelY):\n        global birdY, birdVelY, birdX, physxCounter, physxDebug, birdScrollSpeed\n        dy = targetY - birdY\n        discr = birdVelY * birdVelY + 2 * accelY * dy\n        if discr < 0:\n            return [birdX,targetY]\n        tm = (-birdVelY - math.sqrt(discr)) / accelY\n\n        if physxCounter > tm:\n            #physxDebug.clear()\n            physxCounter = 0\n\n        physxDebug.append(calculatePosition(physxCounter, accelY))\n        physxCounter = physxCounter + 0.01\n\n        dx = birdScrollSpeed * 50 * time;\n        return [birdX + dx, targetY]\n\n    def birdAI():\n        global obstacles, birdScrollSpeed, playing\n        if(len(obstacles) > 0 and playing == True):\n            collision = predictCollision(obstacles[0][1] + obstacles[0][3]/2,birdScrollSpeed * -200)\n            #if(collision[0] < obstacles[0][0]):\n            #    birdVelY = birdScrollSpeed * 100\n\n    def restart():\n        global birdX, birdY, birdVelY, score, birdScrollSpeed, obstacleRate, obstacles, playing\n        #controller_1.rumble('-')\n        birdY = 0\n        birdX = 0\n        birdVelY = 0\n        score = 0\n        birdScrollSpeed = 3\n        obstacleRate = 50\n        obstacles = []\n        playing = False\n\n    prevAPer = 0\n    prevBPer = 0\n    prevBatPer = 0\n\n    intakeStartTime = 0\n    intakeEnablePrev = False\n\n   # place driver control in this while loop\n    while True:\n       global prevTime, birdX, birdY, birdScrollSpeed, obstacleRate, prevJump, onstacleCounter, playing, score, birdVelY, prevXBtn\n       time = brain.timer.time(MSEC)\n       delta = (time - prevTime) / 1000\n       prevTime = time\n\n       veloc = \"none\"\n\n       intakeEnable = controller_1.buttonR1.pressing() or controller_1.buttonR2.pressing()\n       if intakeEnable and intakeEnablePrev == False:\n           intakeStartTime = time\n       intakeEnablePrev= intakeEnable\n\n       if intakeEnable:\n           intake.spin(FORWARD if controller_1.buttonR1.pressing() else REVERSE)\n           curveDelta = (time - intakeStartTime) / 1000\n           veloc = str(intakeCurve(curveDelta, 1 if controller_1.buttonR1.pressing() else -1))\n       else:\n           intake.stop()\n\n       brain.screen.set_pen_color(Color.TRANSPARENT);\n       brain.screen.set_fill_color(Color.BLACK);\n       brain.screen.draw_rectangle(280,0,200,300)\n       brain.screen.set_pen_width(1)\n       brain.screen.set_pen_color(Color.WHITE);\n       brain.screen.set_fill_color(Color.TRANSPARENT);\n       a = flywheel_motor_a.temperature(PERCENT)/100\n       b = flywheel_motor_b.temperature(PERCENT)/100\n       ld = left_drive_smart.temperature(PERCENT)/100\n       lr = right_drive_smart.temperature(PERCENT)/100\n       drawGraph(a,b,10,10,15,3, Color.BLUE, Color.RED)\n       drawGraph(ld,lr,10,130,15,9, Color.GREEN, Color.YELLOW)\n\n       brain.screen.set_cursor(1,1)\n       brain.screen.print(veloc)\n       \n       birdX = birdX + birdScrollSpeed * 50 * delta\n       birdScrollSpeed = birdScrollSpeed + delta * 0.2\n       obstacleRate = obstacleRate - delta * 0.7\n       if (obstacleRate < 5):\n           obstacleRate = 5\n\n       jumpBtn = controller_1.buttonA.pressing()\n       if(jumpBtn and prevJump == False):\n           playing = True\n           birdVelY = birdScrollSpeed * 100\n       prevJump = jumpBtn\n\n       onstacleCounter = onstacleCounter + 1\n       if (onstacleCounter >= obstacleRate and playing == True):\n            onstacleCounter = 0\n            obstacles.append([birdX + 170, random.randint(40, 220 - 90), 30, 90])\n\n       hiddenCount = 0\n       for obs in obstacles:\n           brain.screen.set_fill_color(Color.ORANGE)\n           brain.screen.set_pen_color(Color.WHITE)\n           \n           x1 = obs[0]\n           y1 = obs[1]\n           x2 = x1 + obs[2]\n           y2 = y1 + obs[3]\n\n           passed = birdX < x1 or birdX > x2 or (birdY > y1 and birdY < y2)\n           if(passed == False):\n               restart()\n               break\n\n           x1 = x1 - birdX + 320\n           x2 = x2 - birdX + 320\n           y1 = 220 - y1\n           y2 = 220 - y2\n           if(y2 < y1):\n               temp1 = y1\n               y1 = y2\n               y2 = temp1\n           if(birdX - obs[0] > 30):\n               hiddenCount = hiddenCount + 1\n\n           rc1 = [x1,0,x2,y1]\n           rc2 =[x1,y2,x2,270]\n\n           brain.screen.draw_rectangle(rc1[0], rc1[1], rc1[2] - rc1[0], rc1[3] - rc1[1])\n           brain.screen.draw_rectangle(rc2[0], rc2[1], rc2[2] - rc2[0], rc2[3] - rc2[1])\n\n       if(hiddenCount > 0):\n            del obstacles[:hiddenCount]\n       score = score + hiddenCount # number of passed obstacles\n\n       # flappy bird (yay!)\n       birdVelY = birdVelY - birdScrollSpeed * 500 * delta\n       birdAI()\n       brain.screen.set_pen_color(Color.WHITE)\n       brain.screen.set_pen_width(2)\n       if len(physxDebug) > 0:\n            prevPt = physxDebug[0]\n            for i in range(0,len(physxDebug)):\n                dbg = physxDebug[i]\n                brain.screen.draw_line(prevPt[0] - birdX + 320, 260 - prevPt[1],\n                dbg[0] - birdX + 320, 260 - dbg[1])\n                prevPt = dbg\n\n       brain.screen.set_pen_width(1)\n       birdY = birdY + birdVelY * delta\n       if birdY <= 0:\n           restart()\n  \n       if birdY >= 250:\n           restart()\n\n       brain.screen.set_pen_width(2)\n       brain.screen.set_pen_color(Color.WHITE);\n       brain.screen.set_fill_color(Color.YELLOW);\n       brain.screen.draw_circle(320,220-birdY,10);\n\n       brain.screen.set_pen_color(Color.WHITE)\n       brain.screen.set_fill_color(Color.TRANSPARENT)\n       brain.screen.set_font(FontType.PROP20)\n       brain.screen.set_cursor(2,30)\n       brain.screen.print(\"Score: \" + str(score))\n\n       brain.screen.render()\n\n       if(controller_1.buttonB.pressing()):\n           indexer.set_position(0, DEGREES)\n           indexer.spin_for(REVERSE, 1, TURNS)\n           indexer.spin_to_position(-360, DEGREES)\n       if(delta < 0.02):\n           wait((0.02 - delta)*1000, MSEC)\n\n       if (controller_1.buttonLeft.pressing() == False):\n           expansionCounter = 0\n           led_a.on()\n       else:\n           led_a.off()\n       \n       if (controller_1.buttonX.pressing() and prevXBtn == False):\n           expansionCounter = expansionCounter + 1\n           if(expansionCounter == 3):\n                expansion.set_position(0, DEGREES)\n                expansion.spin_for(FORWARD, 30, DEGREES)\n                expansion.spin_to_position(0, DEGREES)\n\n       prevXBtn = controller_1.buttonX.pressing()\n\n    running = False\n\n# create competition instance\ncomp = Competition(user_control, autonomous)\npre_autonomous()\n","textLanguage":"python","rconfig":[{"port":[1,2],"name":"flywheel","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[3],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"roller","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[5],"name":"indexer","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8,7,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel4in","gear":"ratio36_1","gearRatio":"1:1","direction":"fwd","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"flywheel","leftDir":"false","right":"","rightDir":"false","upDown":"roller","upDownDir":"false","xB":"","xBDir":"false","drive":"split","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"led_a","customName":false,"deviceType":"LED","deviceClass":"led","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"expansion","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}